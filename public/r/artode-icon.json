{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "artode-icon",
  "type": "registry:ui",
  "registryDependencies": [],
  "dependencies": [],
  "devDependencies": [],
  "files": [
    {
      "path": "artode-icon.tsx",
      "content": "\"use client\";\n\nimport React, { useEffect, useRef } from 'react';\n\nimport { InteractiveArtodeIcon } from './interactive-artode-icon';\n\nexport interface ArtodeIconProps {\n    /** SVG Path string for the icon shape */\n    path: string;\n    /** Size of the canvas/icon in pixels */\n    size?: number;\n    /** Override the primary Swiss Red color */\n    color?: string;\n    /** ClassName for additional styling */\n    className?: string;\n    /** Force hover state for animation control */\n    forceHover?: boolean;\n    /** Draw either the stroke or the fill of the SVG path */\n    drawType?: 'fill' | 'stroke';\n    /** Enable interactive particle mode */\n    interactive?: boolean;\n    /** Enable global mouse tracking for interactive mode */\n    globalMouse?: boolean;\n    /** Custom canvas size for interactive mode (width, height) */\n    customCanvasSize?: { width: number; height: number };\n    /** Custom viewBox size of the SVG path. Defaults to 24. */\n    viewBoxSize?: number;\n}\n\nexport const ArtodeIcon: React.FC<ArtodeIconProps> = ({\n    path: pathString,\n    size = 32,\n    color = 'currentColor',\n    className,\n    forceHover = false,\n    drawType = 'fill',\n    interactive = false,\n    globalMouse = false,\n    customCanvasSize,\n    viewBoxSize = 24\n}) => {\n    const canvasRef = useRef<HTMLCanvasElement>(null);\n    const [internalHover, setInternalHover] = React.useState(false);\n    const [resolvedColor, setResolvedColor] = React.useState(color === 'currentColor' ? '#D80018' : color);\n    const isHovered = forceHover || internalHover;\n\n    // Resolve 'currentColor' from the parent element's computed style\n    useEffect(() => {\n        if (color !== 'currentColor') {\n            setResolvedColor(color);\n            return;\n        }\n        const canvas = canvasRef.current;\n        if (!canvas) return;\n\n        const computedColor = window.getComputedStyle(canvas).color;\n        setResolvedColor(computedColor || '#D80018');\n    }, [color, className]);\n\n    if (interactive) {\n        return (\n            <InteractiveArtodeIcon\n                path={pathString}\n                size={size}\n                color={resolvedColor}\n                className={className}\n                forceHover={forceHover}\n                globalMouse={globalMouse}\n                customCanvasSize={customCanvasSize}\n                viewBoxSize={viewBoxSize}\n            />\n        );\n    }\n\n    useEffect(() => {\n        const canvas = canvasRef.current;\n        if (!canvas) return;\n        const ctx = canvas.getContext('2d');\n        if (!ctx) return;\n\n        // High DPI support\n        const dpr = window.devicePixelRatio || 1;\n\n        if (canvas.width !== size * dpr) {\n            canvas.width = size * dpr;\n            canvas.height = size * dpr;\n            canvas.style.width = `${size}px`;\n            canvas.style.height = `${size}px`;\n            ctx.scale(dpr, dpr);\n        }\n\n        // 1. Create Mask using Path2D\n        const maskCanvas = document.createElement('canvas');\n        maskCanvas.width = size;\n        maskCanvas.height = size;\n        const maskCtx = maskCanvas.getContext('2d');\n        if (!maskCtx) return;\n\n        const path = new Path2D(pathString);\n\n        maskCtx.fillStyle = '#000';\n        maskCtx.strokeStyle = '#000';\n        maskCtx.lineWidth = 2; // Default stroke width\n\n        // Assumption: Input paths are normalized to a standard viewport (e.g., 24x24 like Lucide/Material)\n        // Adjust scale to fill the requested size\n        const scale = size / viewBoxSize;\n        maskCtx.scale(scale, scale);\n\n        if (drawType === 'stroke') {\n            maskCtx.stroke(path);\n        } else {\n            // Use evenodd rule to handle complex paths with holes (like X or WhatsApp)\n            maskCtx.fill(path, \"evenodd\");\n        }\n\n        const maskData = maskCtx.getImageData(0, 0, size, size).data;\n\n        // 2. Wave Sources for Interference Pattern (matching ArtodesGitHub.tsx style)\n        const sources = [\n            { x: size * 0.2, y: size * 0.2, wavelength: size * 0.125, phase: 0 },\n            { x: size * 0.8, y: size * 0.8, wavelength: size * 0.1875, phase: Math.PI },\n            { x: size * 0.5, y: size * 1.5, wavelength: size * 0.25, phase: Math.PI * 0.5 }\n        ];\n\n        let time = 0;\n        let animId: number;\n\n        const render = () => {\n            if (isHovered) {\n                time += 0.005; // Slightly faster animation on hover\n            } else {\n                // Static time for idle state to show some texture but no movement\n                time = 1.0;\n            }\n\n            ctx.clearRect(0, 0, size, size);\n            ctx.fillStyle = resolvedColor;\n\n            // Optimization: Iterate pixels\n            // For small icons (e.g. 32x32), iterating all pixels is cheap ~1024 iterations\n            for (let y = 0; y < size; y++) {\n                for (let x = 0; x < size; x++) {\n                    const index = (y * size + x) * 4;\n                    const alpha = maskData[index + 3];\n\n                    if (alpha > 100) {\n                        // Base visibility (dimmed background of the shape)\n                        // If not hovered, make it more solid/readable\n                        ctx.globalAlpha = isHovered ? 0.5 : 0.7;\n                        ctx.fillRect(x, y, 1, 1);\n\n                        // Only calculate waves if hovered to save CPU\n                        if (isHovered) {\n                            // Wave Calculation\n                            let amplitude = 0;\n                            for (const source of sources) {\n                                const dx = x - source.x;\n                                const dy = y - source.y;\n                                const dist = Math.sqrt(dx * dx + dy * dy);\n                                amplitude += Math.sin((dist / source.wavelength - time * 10) * 2 * Math.PI + source.phase);\n                            }\n\n                            // Normalize amplitude to 0-1 range roughly\n                            const normalized = (amplitude + sources.length) / (sources.length * 2);\n                            const val = (normalized * 5) % 1;\n\n                            // Threshold for the \"bright\" wave lines\n                            if (val > 0.65) {\n                                ctx.globalAlpha = 1.0;\n                                ctx.fillRect(x, y, 1, 1);\n                            }\n                        }\n                    }\n                }\n            }\n\n            if (isHovered) {\n                animId = requestAnimationFrame(render);\n            }\n        };\n\n        // Initial render\n        render();\n\n        return () => {\n            if (animId) cancelAnimationFrame(animId);\n        };\n    }, [pathString, size, resolvedColor, isHovered, drawType, viewBoxSize]);\n\n    return (\n        <canvas\n            ref={canvasRef}\n            className={`transition-opacity ${className || ''}`}\n            aria-hidden=\"true\"\n            onMouseEnter={() => setInternalHover(true)}\n            onMouseLeave={() => setInternalHover(false)}\n        />\n    );\n};\n",
      "type": "registry:ui"
    }
  ]
}
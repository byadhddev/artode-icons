{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "artode-icon",
  "type": "registry:ui",
  "registryDependencies": [],
  "dependencies": [],
  "devDependencies": [],
  "files": [
    {
      "path": "artode-icon.tsx",
      "content": "\"use client\";\n\nimport React, { useEffect, useRef } from 'react';\n\ninterface ArtodeIconProps {\n    /** SVG Path string for the icon shape */\n    path: string;\n    /** Size of the canvas/icon in pixels */\n    size?: number;\n    /** Override the primary Swiss Red color */\n    color?: string;\n    /** ClassName for additional styling */\n    className?: string;\n}\n\nexport const ArtodeIcon: React.FC<ArtodeIconProps> = ({\n    path: pathString,\n    size = 32,\n    color = '#D80018',\n    className\n}) => {\n    const canvasRef = useRef<HTMLCanvasElement>(null);\n    const [isHovered, setIsHovered] = React.useState(false);\n\n    useEffect(() => {\n        const canvas = canvasRef.current;\n        if (!canvas) return;\n        const ctx = canvas.getContext('2d');\n        if (!ctx) return;\n\n        // High DPI support\n        const dpr = window.devicePixelRatio || 1;\n\n        if (canvas.width !== size * dpr) {\n            canvas.width = size * dpr;\n            canvas.height = size * dpr;\n            canvas.style.width = `${size}px`;\n            canvas.style.height = `${size}px`;\n            ctx.scale(dpr, dpr);\n        }\n\n        // 1. Create Mask using Path2D\n        const maskCanvas = document.createElement('canvas');\n        maskCanvas.width = size;\n        maskCanvas.height = size;\n        const maskCtx = maskCanvas.getContext('2d');\n        if (!maskCtx) return;\n\n        const path = new Path2D(pathString);\n\n        maskCtx.fillStyle = '#000';\n\n        // Assumption: Input paths are normalized to a standard viewport (e.g., 24x24 like Lucide/Material)\n        // Adjust scale to fill the requested size\n        const scale = size / 24;\n        maskCtx.scale(scale, scale);\n\n        // Use evenodd rule to handle complex paths with holes (like X or WhatsApp)\n        maskCtx.fill(path, \"evenodd\");\n\n        const maskData = maskCtx.getImageData(0, 0, size, size).data;\n\n        // 2. Wave Sources for Interference Pattern (matching ArtodesGitHub.tsx style)\n        const sources = [\n            { x: size * 0.2, y: size * 0.2, wavelength: size * 0.125, phase: 0 },\n            { x: size * 0.8, y: size * 0.8, wavelength: size * 0.1875, phase: Math.PI },\n            { x: size * 0.5, y: size * 1.5, wavelength: size * 0.25, phase: Math.PI * 0.5 }\n        ];\n\n        let time = 0;\n        let animId: number;\n\n        const render = () => {\n            if (isHovered) {\n                time += 0.005; // Slightly faster animation on hover\n            } else {\n                // Static time for idle state to show some texture but no movement\n                time = 1.0;\n            }\n\n            ctx.clearRect(0, 0, size, size);\n            ctx.fillStyle = color;\n\n            // Optimization: Iterate pixels\n            // For small icons (e.g. 32x32), iterating all pixels is cheap ~1024 iterations\n            for (let y = 0; y < size; y++) {\n                for (let x = 0; x < size; x++) {\n                    const index = (y * size + x) * 4;\n                    const alpha = maskData[index + 3];\n\n                    if (alpha > 100) {\n                        // Base visibility (dimmed background of the shape)\n                        // If not hovered, make it more solid/readable\n                        ctx.globalAlpha = isHovered ? 0.5 : 0.7;\n                        ctx.fillRect(x, y, 1, 1);\n\n                        // Only calculate waves if hovered to save CPU\n                        if (isHovered) {\n                            // Wave Calculation\n                            let amplitude = 0;\n                            for (const source of sources) {\n                                const dx = x - source.x;\n                                const dy = y - source.y;\n                                const dist = Math.sqrt(dx * dx + dy * dy);\n                                amplitude += Math.sin((dist / source.wavelength - time * 10) * 2 * Math.PI + source.phase);\n                            }\n\n                            // Normalize amplitude to 0-1 range roughly\n                            const normalized = (amplitude + sources.length) / (sources.length * 2);\n                            const val = (normalized * 5) % 1;\n\n                            // Threshold for the \"bright\" wave lines\n                            if (val > 0.65) {\n                                ctx.globalAlpha = 1.0;\n                                ctx.fillRect(x, y, 1, 1);\n                            }\n                        }\n                    }\n                }\n            }\n\n            if (isHovered) {\n                animId = requestAnimationFrame(render);\n            }\n        };\n\n        // Initial render\n        render();\n\n        return () => {\n            if (animId) cancelAnimationFrame(animId);\n        };\n    }, [pathString, size, color, isHovered]);\n\n    return (\n        <canvas\n            ref={canvasRef}\n            className={`transition-opacity ${className || ''}`}\n            aria-hidden=\"true\"\n            onMouseEnter={() => setIsHovered(true)}\n            onMouseLeave={() => setIsHovered(false)}\n        />\n    );\n};\n",
      "type": "registry:ui"
    }
  ]
}